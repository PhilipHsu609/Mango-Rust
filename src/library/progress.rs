use crate::error::Result;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::Path;

/// Structure for storing title metadata and progress in info.json
/// Compatible with original Mango's info.json format
#[derive(Debug, Serialize, Deserialize)]
pub struct TitleInfo {
    /// Comment field for compatibility with original Mango
    #[serde(default = "default_comment")]
    pub comment: String,

    /// Progress tracking: username -> entry_id -> page_number
    #[serde(default)]
    pub progress: HashMap<String, HashMap<String, usize>>,

    /// Custom display name for the title
    #[serde(default)]
    pub display_name: String,

    /// Custom display names for entries: entry_id -> display_name
    #[serde(default)]
    pub entry_display_name: HashMap<String, String>,

    /// Custom cover URL for the title
    #[serde(default)]
    pub cover_url: String,

    /// Custom cover URLs for entries: entry_id -> cover_url
    #[serde(default)]
    pub entry_cover_url: HashMap<String, String>,

    /// Last read timestamp: username -> entry_id -> unix_timestamp
    #[serde(default)]
    pub last_read: HashMap<String, HashMap<String, i64>>,

    /// Date added timestamp: entry_id -> unix_timestamp
    #[serde(default)]
    pub date_added: HashMap<String, i64>,

    /// Sorting preferences: username -> (sort_method, ascending)
    #[serde(default)]
    pub sort_by: HashMap<String, (String, bool)>,
}

fn default_comment() -> String {
    "Generated by Mango. DO NOT EDIT!".to_string()
}

impl Default for TitleInfo {
    fn default() -> Self {
        TitleInfo {
            comment: default_comment(),
            progress: HashMap::new(),
            display_name: String::new(),
            entry_display_name: HashMap::new(),
            cover_url: String::new(),
            entry_cover_url: HashMap::new(),
            last_read: HashMap::new(),
            date_added: HashMap::new(),
            sort_by: HashMap::new(),
        }
    }
}

impl TitleInfo {
    /// Load TitleInfo from a directory's info.json file
    pub async fn load(dir: &Path) -> Result<Self> {
        let info_path = dir.join("info.json");

        if !info_path.exists() {
            return Ok(TitleInfo::default());
        }

        let content = tokio::fs::read_to_string(&info_path).await?;
        let mut info: TitleInfo = serde_json::from_str(&content).unwrap_or_default();

        // Ensure comment field is set for loaded files that might not have it
        if info.comment.is_empty() {
            info.comment = default_comment();
        }

        Ok(info)
    }

    /// Save TitleInfo to a directory's info.json file
    pub async fn save(&self, dir: &Path) -> Result<()> {
        let info_path = dir.join("info.json");

        // Only delete the file if there's no data at all (no progress and no sort preferences)
        if self.progress.is_empty() && self.sort_by.is_empty() {
            if info_path.exists() {
                tokio::fs::remove_file(&info_path).await?;
            }
            return Ok(());
        }

        let json = serde_json::to_string_pretty(self)?;
        tokio::fs::write(&info_path, json).await?;

        Ok(())
    }

    /// Get progress for a specific user and entry
    pub fn get_progress(&self, username: &str, entry_id: &str) -> Option<usize> {
        self.progress
            .get(username)
            .and_then(|user_progress| user_progress.get(entry_id))
            .copied()
    }

    /// Set progress for a specific user and entry
    pub fn set_progress(&mut self, username: &str, entry_id: &str, page: usize) {
        self.progress
            .entry(username.to_string())
            .or_default()
            .insert(entry_id.to_string(), page);

        // Update last_read timestamp
        self.set_last_read(username, entry_id, chrono::Utc::now().timestamp());
    }

    /// Remove progress for a specific user and entry
    pub fn remove_progress(&mut self, username: &str, entry_id: &str) {
        if let Some(user_progress) = self.progress.get_mut(username) {
            user_progress.remove(entry_id);
            // If user has no more progress entries, remove the user
            if user_progress.is_empty() {
                self.progress.remove(username);
            }
        }
    }

    /// Get last read timestamp for a specific user and entry
    pub fn get_last_read(&self, username: &str, entry_id: &str) -> Option<i64> {
        self.last_read
            .get(username)
            .and_then(|user_last_read| user_last_read.get(entry_id))
            .copied()
    }

    /// Set last read timestamp for a specific user and entry
    pub fn set_last_read(&mut self, username: &str, entry_id: &str, timestamp: i64) {
        self.last_read
            .entry(username.to_string())
            .or_default()
            .insert(entry_id.to_string(), timestamp);
    }

    /// Get date added timestamp for an entry
    pub fn get_date_added(&self, entry_id: &str) -> Option<i64> {
        self.date_added.get(entry_id).copied()
    }

    /// Set date added timestamp for an entry
    pub fn set_date_added(&mut self, entry_id: &str, timestamp: i64) {
        self.date_added.insert(entry_id.to_string(), timestamp);
    }

    /// Set date added for an entry if not already set
    pub fn set_date_added_if_new(&mut self, entry_id: &str, timestamp: i64) {
        self.date_added.entry(entry_id.to_string()).or_insert(timestamp);
    }

    /// Get sort preference for a specific user
    /// Returns (sort_method, ascending) tuple
    pub fn get_sort_by(&self, username: &str) -> Option<(String, bool)> {
        self.sort_by.get(username).cloned()
    }

    /// Set sort preference for a specific user
    pub fn set_sort_by(&mut self, username: &str, method: &str, ascending: bool) {
        self.sort_by.insert(username.to_string(), (method.to_string(), ascending));
    }
}
